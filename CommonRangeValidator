// File: ValidationBundle.cs
// Drop this single file into your ASP.NET Web API (.NET Framework 4.8) project.
// Requires Newtonsoft.Json (Json.NET).

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Reflection;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.Filters;
using System.Web.Http.ModelBinding;
using Newtonsoft.Json;

namespace ValidationBundle
{
    // ---------------------------
    // A) Catch JSON overflow/format errors early (e.g., 2147483648 to int)
    // ---------------------------
    public sealed class JsonExceptionFilter : ExceptionFilterAttribute
    {
        public string MessageForIntOverflow { get; set; } =
            "One or more numeric values are too large or have an invalid format.";

        public override void OnException(HttpActionExecutedContext context)
        {
            if (context.Exception is JsonReaderException || context.Exception is JsonSerializationException)
            {
                var detail = new
                {
                    title = "Input validation failed",
                    status = 400,
                    errors = new Dictionary<string, string[]>
                    {
                        { "", new [] { MessageForIntOverflow } }
                    }
                };
                context.Response = context.Request.CreateResponse(HttpStatusCode.BadRequest, detail);
            }
        }
    }

    // ---------------------------
    // B) Normalize ModelState errors into friendly, consistent text
    // ---------------------------
    public sealed class ModelStateToFriendlyMessageFilter : ActionFilterAttribute
    {
        public string FallbackMessage { get; set; } =
            "Please check the input values and try again.";

        public string IntMessage { get; set; } =
            "Value must be a valid 32-bit integer (≤ 2,147,483,647).";

        public string LongMessage { get; set; } =
            "Value must be a valid 64-bit integer.";

        public override void OnActionExecuting(HttpActionContext actionContext)
        {
            if (!actionContext.ModelState.IsValid)
            {
                // FIX #1: preserve user-defined messages added earlier (do NOT overwrite non-empty messages)
                foreach (var kv in actionContext.ModelState.ToList())
                {
                    var entry = kv.Value;
                    for (int i = 0; i < entry.Errors.Count; i++)
                    {
                        var err = entry.Errors[i];
                        if (!string.IsNullOrWhiteSpace(err.ErrorMessage))
                            continue; // <-- keep NumericRangeGuardFilter messages intact

                        var raw = err.Exception?.Message ?? string.Empty;
                        if (raw.IndexOf("Int32", StringComparison.OrdinalIgnoreCase) >= 0
                            || raw.IndexOf("could not be converted to System.Int32", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            err.ErrorMessage = IntMessage;
                        }
                        else if (raw.IndexOf("Int64", StringComparison.OrdinalIgnoreCase) >= 0
                                 || raw.IndexOf("could not be converted to System.Int64", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            err.ErrorMessage = LongMessage;
                        }
                        else
                        {
                            err.ErrorMessage = FallbackMessage;
                        }
                    }
                }

                actionContext.Response = BuildProblemDetails(actionContext.ModelState, actionContext.Request);
            }
        }

        private static HttpResponseMessage BuildProblemDetails(ModelStateDictionary modelState, HttpRequestMessage request)
        {
            var problem = new
            {
                title = "Input validation failed",
                status = 400,
                errors = modelState
                    .Where(k => k.Value.Errors.Any())
                    .ToDictionary(
                        k => k.Key,
                        k => k.Value.Errors.Select(e => e.ErrorMessage).ToArray()
                    )
            };
            return request.CreateResponse(HttpStatusCode.BadRequest, problem);
        }
    }

    // ---------------------------
    // C) Post-bind guard: walk the DTO graph and cap int/long with your own messages
    // ---------------------------
    public sealed class NumericRangeGuardFilter : ActionFilterAttribute
    {
        private readonly long _maxForInt;
        private readonly long _maxForLong;
        private readonly HashSet<string> _excludeProps;

        public NumericRangeGuardFilter(long maxForInt, long maxForLong, IEnumerable<string> excludePropertyNames = null)
        {
            _maxForInt = maxForInt;
            _maxForLong = maxForLong;
            _excludeProps = excludePropertyNames != null
                ? new HashSet<string>(excludePropertyNames, StringComparer.OrdinalIgnoreCase)
                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }

        public string IntExceededMessage { get; set; }  = "Value must be ≤ {0}.";
        public string LongExceededMessage { get; set; } = "Value must be ≤ {0}.";

        public override void OnActionExecuting(HttpActionContext actionContext)
        {
            foreach (var arg in actionContext.ActionArguments)
            {
                var val = arg.Value;
                if (val != null)
                    ValidateObject(val, arg.Key, actionContext, 0);
            }

            if (!actionContext.ModelState.IsValid)
            {
                var problem = new
                {
                    title = "Input validation failed",
                    status = 400,
                    errors = actionContext.ModelState
                        .Where(k => k.Value.Errors.Any())
                        .ToDictionary(
                            k => k.Key,
                            k => k.Value.Errors.Select(e => e.ErrorMessage).ToArray()
                        )
                };
                actionContext.Response = actionContext.Request.CreateResponse(HttpStatusCode.BadRequest, problem);
            }
        }

        private void ValidateObject(object obj, string path, HttpActionContext ctx, int depth)
        {
            if (obj == null || depth > 8) return;

            if (obj is IEnumerable enumerable && !(obj is string))
            {
                int i = 0;
                foreach (var item in enumerable)
                {
                    ValidateObject(item, $"{path}[{i}]", ctx, depth + 1);
                    i++;
                }
                return;
            }

            var t = obj.GetType();
            if (IsPrimitiveLike(t)) return;

            var props = t.GetProperties(BindingFlags.Instance | BindingFlags.Public)
                         .Where(p => p.CanRead && !_excludeProps.Contains(p.Name));

            foreach (var p in props)
            {
                var propPath = $"{path}.{p.Name}";
                var value = p.GetValue(obj);
                var u = Nullable.GetUnderlyingType(p.PropertyType) ?? p.PropertyType;

                if (u == typeof(int))
                {
                    if (value != null)
                    {
                        int v = (int)value;
                        if (v > _maxForInt)
                            ctx.ModelState.AddModelError(propPath, string.Format(IntExceededMessage, _maxForInt));
                    }
                }
                else if (u == typeof(long))
                {
                    if (value != null)
                    {
                        long v = (long)value;
                        if (v > _maxForLong)
                            ctx.ModelState.AddModelError(propPath, string.Format(LongExceededMessage, _maxForLong));
                    }
                }
                else if (!IsPrimitiveLike(u) && value != null)
                {
                    ValidateObject(value, propPath, ctx, depth + 1);
                }
            }
        }

        private static bool IsPrimitiveLike(Type t)
        {
            if (t.IsPrimitive) return true;
            return t == typeof(string)
                || t == typeof(decimal)
                || t == typeof(DateTime)
                || t == typeof(Guid)
                || t == typeof(DateTimeOffset)
                || t == typeof(TimeSpan);
        }
    }

    // ---------------------------
    // D) Web API configuration (register routes + filters here)
    // ---------------------------
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            config.MapHttpAttributeRoutes();
            config.Routes.MapHttpRoute(
                name: "DefaultApi",
                routeTemplate: "api/{controller}/{id}",
                defaults: new { id = RouteParameter.Optional }
            );

            config.Filters.Add(new JsonExceptionFilter
            {
                MessageForIntOverflow = "One or more numeric values are too large."
            });

            // FIX #2: run the range guard BEFORE the friendly message filter
            config.Filters.Add(new NumericRangeGuardFilter(
                maxForInt: int.MaxValue,
                maxForLong: int.MaxValue,
                excludePropertyNames: new[] { "UnboundedField" }
            )
            {
                IntExceededMessage  = "Value must be ≤ 2,147,483,647.",
                LongExceededMessage = "Value must be ≤ 2,147,483,647."
            });

            // Friendly normalizer goes last so it can format binder errors,
            // but (due to FIX #1) it will NOT overwrite your custom messages.
            config.Filters.Add(new ModelStateToFriendlyMessageFilter
            {
                IntMessage = "Value must be a valid 32-bit integer (≤ 2,147,483,647).",
                LongMessage = "Value must be a valid 64-bit integer (≤ 9,223,372,036,854,775,807).",
                FallbackMessage = "Invalid value."
            });
        }
    }

    // ---------------------------
    // E) Sample DTOs (supports nesting & lists)
    // ---------------------------
    public class MyDto
    {
        public int  Quantity { get; set; }
        public long Price   { get; set; }
        public long? Budget { get; set; }
        public ChildDto Child { get; set; }
        public List<ChildDto> Items { get; set; }
    }

    public class ChildDto
    {
        public long BigNumber { get; set; }
        public int? SmallNumber { get; set; }
    }

    // ---------------------------
    // F) Sample controller to test
    // ---------------------------
    [RoutePrefix("api/test")]
    public class TestController : ApiController
    {
        [HttpPost, Route("validate")]
        public IHttpActionResult ValidateDto(MyDto dto)
        {
            return Ok(new { message = "Valid input!" });
        }
    }
}

/*
WHERE IT'S FIXED:
- FIX #1 in ModelStateToFriendlyMessageFilter.OnActionExecuting:
  We now skip overwriting any non-empty ModelState error messages, so messages
  added by NumericRangeGuardFilter like "Value must be ≤ 2,147,483,647." are preserved.

- FIX #2 in WebApiConfig.Register:
  We register NumericRangeGuardFilter BEFORE ModelStateToFriendlyMessageFilter so that
  if the friendly filter builds the response, it already includes your custom messages.
*/
